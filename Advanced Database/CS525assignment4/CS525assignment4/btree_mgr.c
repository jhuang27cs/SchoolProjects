#include "btree_mgr.h"#include "tables.h"#include "buffer_mgr.h"#include "record_mgr.h"#include "storage_mgr.h"#include <stdio.h>#include <stdlib.h>#include <string.h>typedef struct Tree{    struct Value val;    struct RID rid;}Tree;int entry;int nextentry;Tree **btreeManager;// init and shutdown index managerRC initIndexManager (void *mgmtData){        btreeManager=(Tree **)malloc(100*sizeof(Tree* ));    return RC_OK;}RC shutdownIndexManager (){    free(btreeManager);    return RC_OK;}// create, destroy, open, and close an btree indexRC createBtree (char *idxId, DataType keyType, int n){    BTreeHandle *tree;    tree=(BTreeHandle *)malloc(sizeof(BTreeHandle)*3);    tree->idxId=idxId;    tree->keyType=keyType;    entry=0;    nextentry=0;    return RC_OK;}RC openBtree (BTreeHandle **tree, char *idxId){    *tree=(BTreeHandle *)malloc(sizeof(tree)*3);    (*tree)->idxId=(char *)malloc(sizeof(char)*4);    (*tree)->idxId=idxId;    return RC_OK;}RC closeBtree (BTreeHandle *tree){    free(tree);    return RC_OK;}RC deleteBtree (char *idxId){    entry=0;    nextentry=0;    return RC_OK;}// access information about a b-treeRC getNumNodes (BTreeHandle *tree, int *result){        int node;    int i,j;    int count=0;    for(i=1;i<entry;i++)    {        for(j=i-1;j>=0;j--)        {            if(btreeManager[i]->rid.page==btreeManager[j]->rid.page)            {                count++;                break;            }        }    }    node=entry-count;    *result=node;    return RC_OK;}RC getNumEntries (BTreeHandle *tree, int *result){    *result=entry;    return RC_OK;}RC getKeyType (BTreeHandle *tree, DataType *result){    *result=tree->keyType;    return RC_OK;}// index accessRC findKey (BTreeHandle *tree, Value *key, RID *result){    int i;    if (key->dt ==DT_INT) {        for(i=0;i<entry;i++)        {            if(btreeManager[i]->val.dt==key->dt && btreeManager[i]->val.v.intV==key->v.intV)            {                result->page=btreeManager[i]->rid.page;                result->slot=btreeManager[i]->rid.slot;                return RC_OK;            }        }            }    return RC_IM_KEY_NOT_FOUND;}RC insertKey (BTreeHandle *tree, Value *key, RID rid){    btreeManager[entry]=(Tree *)malloc(sizeof(Tree));    int i;    bool find=FALSE;    //first check if this key already exists    if (key->dt ==DT_INT) {        for(i=0;i<entry;i++)        {            if(btreeManager[i]->val.dt==key->dt && btreeManager[i]->val.v.intV==key->v.intV)            {                find =TRUE;                return RC_IM_KEY_ALREADY_EXISTS;            }        }        if (find == FALSE) {            btreeManager[entry]->val.dt=key->dt;            btreeManager[entry]->val.v.intV=key->v.intV;            btreeManager[entry]->rid.page=rid.page;            btreeManager[entry]->rid.slot=rid.slot;        }    }    entry++;    return RC_OK;}    RC deleteKey (BTreeHandle *tree, Value *key){    int i,j;    int temp=0;        bool find=FALSE;    //first check if this key already exists    if (key->dt ==DT_INT) {        for(i=0;i<entry;i++)        {            if(btreeManager[i]->val.dt==key->dt && btreeManager[i]->val.v.intV==key->v.intV)            {                find =TRUE;                temp=i+1;                for(j=i;j<entry&&temp<entry;j++)                {                                       btreeManager[j]->val.dt=btreeManager[temp]->val.dt;                    btreeManager[j]->val.v.intV=btreeManager[temp]->val.v.intV;                    btreeManager[j]->rid.page=btreeManager[temp]->rid.page;                    btreeManager[j]->rid.slot=btreeManager[temp]->rid.slot;                    temp++;                }                entry--;                free(btreeManager[j]);                return RC_OK;            }        }    }    return RC_IM_KEY_NOT_FOUND;}RC openTreeScan (BTreeHandle *tree, BT_ScanHandle **handle){    return RC_OK;}void swap(Tree **btree,int a,int b){    Value valtemp;    RID ridtemp;        valtemp.dt=btree[a]->val.dt;    valtemp.v.intV=btree[a]->val.v.intV;    ridtemp.page=btree[a]->rid.page;    ridtemp.slot=btree[a]->rid.slot;        btree[a]->val.dt=btree[b]->val.dt;    btree[a]->val.v.intV=btree[b]->val.v.intV;    btree[a]->rid.page=btree[b]->rid.page;    btree[a]->rid.slot=btree[b]->rid.slot;        btree[b]->val.dt=valtemp.dt;    btree[b]->val.v.intV=valtemp.v.intV;    btree[b]->rid.page=ridtemp.page;    btree[b]->rid.slot=ridtemp.slot;        }RC nextEntry (BT_ScanHandle *handle, RID *result){    //sort    int i,k;    for(i=0;i<entry-1;i++)    {        int pos=i;        for(k=i+1;k<entry;k++)        {            if(btreeManager[k]->val.v.intV<btreeManager[pos]->val.v.intV)            {                pos=k;            }        }        swap(btreeManager,i,pos);            }        if(nextentry<entry)    {        result->page=btreeManager[nextentry]->rid.page;        result->slot=btreeManager[nextentry]->rid.slot;        nextentry++;        return RC_OK;    }    else    {        return RC_IM_NO_MORE_ENTRIES;    }    }RC closeTreeScan (BT_ScanHandle *handle){    free(handle);        return RC_OK;}/* // debug and test functions char *printTree (BTreeHandle *tree) {	return tree->idxId; } */